# 한국어 RAG 최적화 기능의 효용 분석

> **문서 버전**: 1.0.0
> **작성일**: 2025-12-29
> **목적**: Phase 9에서 개발 중인 한국어 RAG 최적화 기능들의 구체적인 효용과 가치 제안

---

## 개요

현재 개발 중인 한국어 RAG 최적화 기능들은 **한국어의 교착어 특성**을 고려하여 RAG 시스템의 검색 및 평가 품질을 실질적으로 향상시킵니다.

**핵심 문제:**
- 기존 공백 기반 토큰화는 한국어에 부적합
- 조사/어미 변형으로 인한 검색 실패
- 의미 단위 청킹 부재로 인한 컨텍스트 손실

**해결책:**
- 형태소 분석 기반 토큰화 (Kiwi)
- 의미 단위 청킹 (문장 경계 존중)
- 하이브리드 검색 (BM25 + Dense)

---

## 1. KoreanBM25Retriever (형태소 분석 기반 BM25)

### 1.1 해결하는 문제

#### 문제 1: 공백 기반 토큰화의 한계

```
[기존 방식 - 공백 기반]
질문: "보험료가 얼마인가요?"
토큰화: ["보험료가", "얼마인가요?"]
검색 실패: 문서에 "보험료는" 또는 "보험료를"로만 존재

[형태소 분석 기반]
질문: "보험료가 얼마인가요?"
형태소 분석: ["보험료", "얼마", "인가요"] (조사/어미 제거)
검색 성공: "보험료는", "보험료를", "보험료가" 모두 매칭
```

#### 문제 2: 조사/어미 변형 무시

한국어는 교착어 특성상 동일한 의미라도 조사/어미가 달라집니다:

```
동일한 의미, 다른 표면형:
- "보험료가 인상되었습니다"
- "보험료를 납입합니다"
- "보험료는 30만원입니다"
- "보험료로 계산합니다"

→ 형태소 분석 후 모두 "보험료"로 정규화
```

### 1.2 제공하는 효용

#### 효용 1: 검색 정확도 향상

**Before (공백 기반):**
```python
# 질문: "보험료 납입 기간"
# 문서: "보험료는 매월 납입하여야 합니다"
# 결과: 매칭 실패 (토큰 불일치)
```

**After (형태소 분석):**
```python
# 질문: "보험료 납입 기간"
#   → 형태소: ["보험료", "납입", "기간"]
# 문서: "보험료는 매월 납입하여야 합니다"
#   → 형태소: ["보험료", "매월", "납입", "하여야", "합니다"]
# 결과: 매칭 성공 (핵심 토큰 일치)
```

**예상 개선율:**
- Recall@5: **+15-25% 향상** (문서에서)
- Precision@5: **+10-15% 향상**

#### 효용 2: 도메인 용어 정확한 매칭

보험 도메인에서 중요한 용어들이 정확히 매칭됩니다:

```
[보험 용어 예시]
- "사망보험금" (복합명사)
- "재해사망보험금" (3단어 복합명사)
- "보험가입금액" (복합명사)

형태소 분석:
- "사망보험금" → ["사망", "보험금"]
- "재해사망보험금" → ["재해", "사망", "보험금"]
- "보험가입금액" → ["보험", "가입", "금액"]

→ 복합명사도 정확히 분해하여 검색 가능
```

#### 효용 3: 사용자 사전 지원

도메인 특화 용어를 사용자 사전에 추가하여 정확도 향상:

```python
# 보험 도메인 사용자 사전
user_dict = {
    "종신보험": "NNG",      # 일반명사로 인식
    "정기보험": "NNG",
    "연금보험": "NNG",
    "삼성생명": "NNP",      # 고유명사로 인식
    "한화생명": "NNP",
}

# 사용자 사전 적용 시
"종신보험" → ["종신보험"] (1개 토큰, 정확)
# 사전 없으면 → ["종신", "보험"] (2개 토큰, 의미 분산)
```

### 1.3 실제 사용 시나리오

```
[시나리오: 보험 상담 챗봇]

사용자 질문: "보험료가 얼마인가요?"

[기존 방식]
1. 공백 기반 토큰화: ["보험료가", "얼마인가요?"]
2. BM25 검색: 문서에서 "보험료가" 정확히 일치하는 문서만 찾음
3. 결과: "보험료는 30만원입니다" 문서를 찾지 못함 ❌

[형태소 분석 기반]
1. 형태소 분석: ["보험료", "얼마", "인가요"]
2. BM25 검색: "보험료" 토큰으로 검색
3. 결과: "보험료는 30만원입니다", "보험료를 납입합니다" 모두 매칭 ✅
4. 상위 결과: "보험료는 30만원입니다" (정확한 답변)
```

---

## 2. KoreanDocumentChunker (문장 기반 청킹)

### 2.1 해결하는 문제

#### 문제 1: 문자 기반 청킹의 의미 단위 무시

```
[기존 방식 - 문자 기반]
문서: "보험료 납입 기간은 20년입니다. 보험료는 매월 납입하여야 합니다."
청크 크기: 30자

청크 1: "보험료 납입 기간은 20년입니다. 보험료는 매월 납입하여야 합니다." (30자 초과)
→ 중간에 잘림: "보험료 납입 기간은 20년입니다. 보험료는 매월 납입하여야 합니다"
→ 의미 손실: 문장이 중간에 끊김

[문장 기반 청킹]
문서: "보험료 납입 기간은 20년입니다. 보험료는 매월 납입하여야 합니다."
문장 분리: ["보험료 납입 기간은 20년입니다.", "보험료는 매월 납입하여야 합니다."]

청크 1: "보험료 납입 기간은 20년입니다." (완전한 문장)
청크 2: "보험료는 매월 납입하여야 합니다." (완전한 문장)
→ 의미 보존: 각 청크가 완전한 문장 단위
```

#### 문제 2: 토큰 수 기준 부재

한국어는 공백이 적어 문자 수 기준으로는 토큰 수를 정확히 예측하기 어렵습니다:

```
[문자 수 기준]
"보험료 납입 기간은 20년입니다" (15자)
→ 실제 토큰 수: 6개 (보험료, 납입, 기간, 20년, 입니다)

[토큰 수 기준]
청크 크기: 500 토큰
→ 정확한 의미 단위로 청킹 가능
```

### 2.2 제공하는 효용

#### 효용 1: 컨텍스트 무결성 보장

**Before (문자 기반):**
```python
# 문서: "보험료 납입 기간은 20년입니다. 보험료는 매월 납입하여야 합니다."
# 청크 크기: 30자

청크 1: "보험료 납입 기간은 20년입니다. 보험료는 매월 납입하여야 합니다"
# 문제: 문장이 중간에 끊김, "합니다"가 잘림
```

**After (문장 기반):**
```python
# 문서: "보험료 납입 기간은 20년입니다. 보험료는 매월 납입하여야 합니다."
# 토큰 수 기준, 문장 경계 존중

청크 1: "보험료 납입 기간은 20년입니다." (완전한 문장)
청크 2: "보험료는 매월 납입하여야 합니다." (완전한 문장)
# 장점: 각 청크가 완전한 의미 단위
```

**효과:**
- RAG 답변 품질 향상: 완전한 문장 단위 컨텍스트 제공
- Faithfulness 점수 향상: 문맥이 끊기지 않아 답변 정확도 향상

#### 효용 2: 토큰 수 기반 정확한 청킹

LLM의 토큰 제한을 정확히 준수:

```python
# LLM 컨텍스트 윈도우: 4096 토큰
# 청크 크기: 500 토큰 (안전 마진 포함)

chunker = KoreanDocumentChunker(
    tokenizer=tokenizer,
    chunk_size=500,        # 토큰 수 기준
    overlap_tokens=50      # 오버랩 토큰 수
)

# 정확히 500 토큰 이하로 청킹
# → LLM에 전달 시 토큰 제한 초과 방지
```

#### 효용 3: 오버랩 처리로 경계 정보 보존

청크 경계에서 중요한 정보가 손실되는 것을 방지:

```python
# 문서 구조:
# 청크 1: "...보험료 납입 기간은 20년입니다."
# 청크 2: "보험료는 매월 납입하여야 합니다. 보험료 미납 시..."

# 오버랩 없음:
#   청크 1: "...보험료 납입 기간은 20년입니다."
#   청크 2: "보험료는 매월 납입하여야 합니다. 보험료 미납 시..."
#   → "보험료 납입 기간"과 "보험료 납입"의 연결 정보 손실

# 오버랩 있음 (50 토큰):
#   청크 1: "...보험료 납입 기간은 20년입니다."
#   청크 2: "...보험료 납입 기간은 20년입니다. 보험료는 매월 납입하여야 합니다. 보험료 미납 시..."
#   → 경계 정보 보존, 문맥 연속성 유지
```

### 2.3 실제 사용 시나리오

```
[시나리오: 긴 보험 약관 문서 처리]

문서: 10,000자 보험 약관
LLM 컨텍스트: 4096 토큰

[기존 방식 - 문자 기반]
1. 500자 단위로 청킹
2. 문제: 문장 중간에 끊김
3. 문제: 실제 토큰 수 예측 불가 (한국어는 공백 적음)
4. 결과: 일부 청크가 토큰 제한 초과 → LLM 오류

[문장 기반 청킹]
1. Kiwi로 문장 분리
2. 토큰 수 기준으로 문장 단위 청킹
3. 각 청크가 완전한 문장으로 구성
4. 결과: 모든 청크가 토큰 제한 내, 의미 무결성 보장
```

---

## 3. KoreanHybridRetriever (BM25 + Dense)

### 3.1 해결하는 문제

#### 문제 1: BM25만으로는 의미 유사도 부족

```
[BM25의 한계]
질문: "보험료를 내지 않으면 어떻게 되나요?"
문서 1: "보험료 미납 시 계약이 해지됩니다" (정확한 답변)
문서 2: "보험료 납입 기간은 20년입니다" (관련 있지만 직접 답변 아님)

BM25 점수:
- 문서 1: 낮음 (토큰 겹침 적음: "보험료", "납입" vs "미납", "해지")
- 문서 2: 높음 (토큰 겹침 많음: "보험료", "납입")

→ 잘못된 문서가 상위에 랭킹됨
```

#### 문제 2: Dense만으로는 정확한 용어 매칭 부족

```
[Dense의 한계]
질문: "사망보험금은 얼마인가요?"
문서 1: "사망보험금은 1억원입니다" (정확한 답변)
문서 2: "재해사망보험금은 2억원입니다" (관련 있지만 다른 보험금)

Dense 유사도:
- 문서 1: 높음 (의미 유사)
- 문서 2: 높음 (의미 유사, "사망보험금"과 "재해사망보험금" 유사)

→ 정확한 용어 매칭이 어려움
```

### 3.2 제공하는 효용

#### 효용 1: 정확한 용어 매칭 + 의미 유사도 통합

**하이브리드 검색의 시너지:**

```python
# 질문: "보험료를 내지 않으면 어떻게 되나요?"

# BM25 검색 결과:
#   1. "보험료 납입 기간은 20년입니다" (점수: 0.8, 토큰 겹침 많음)
#   2. "보험료 미납 시 계약이 해지됩니다" (점수: 0.6, 토큰 겹침 적음)

# Dense 검색 결과:
#   1. "보험료 미납 시 계약이 해지됩니다" (점수: 0.95, 의미 유사)
#   2. "보험료 납입 기간은 20년입니다" (점수: 0.7, 의미 관련)

# 하이브리드 (RRF 융합):
#   1. "보험료 미납 시 계약이 해지됩니다" (최종 점수: 0.92) ✅
#   2. "보험료 납입 기간은 20년입니다" (최종 점수: 0.75)
```

**예상 개선율:**
- Recall@10: **+20-30% 향상**
- Precision@5: **+15-25% 향상**
- MRR (Mean Reciprocal Rank): **+30-40% 향상**

#### 효용 2: 도메인 특화 용어 정확 매칭

보험 도메인에서 중요한 정확한 용어 매칭:

```
[시나리오: 보험 용어 정확 매칭]

질문: "사망보험금은 얼마인가요?"

BM25 (형태소 분석):
- "사망보험금" → ["사망", "보험금"]
- 정확한 용어 매칭 강조

Dense:
- "사망보험금"과 "재해사망보험금"의 의미적 유사도 고려

하이브리드:
- BM25: "사망보험금" 정확 매칭 강조
- Dense: 의미 확장으로 관련 문서도 포함
- 결과: 정확한 답변 + 관련 정보 균형
```

#### 효용 3: 융합 방법 선택 가능

사용 사례에 따라 최적의 융합 방법 선택:

```python
# 방법 1: Reciprocal Rank Fusion (RRF) - 기본
# 장점: 순위 기반, 점수 스케일 불일치 문제 해결
retriever = KoreanHybridRetriever(
    tokenizer=tokenizer,
    fusion_method=FusionMethod.RRF,
    rrf_k=60  # RRF k 파라미터
)

# 방법 2: Weighted Sum - 가중치 조정 가능
# 장점: 도메인에 따라 BM25/Dense 비중 조정
retriever = KoreanHybridRetriever(
    tokenizer=tokenizer,
    bm25_weight=0.6,    # 보험 도메인: 정확한 용어 매칭 중요
    dense_weight=0.4,
    fusion_method=FusionMethod.WEIGHTED_SUM
)

# 방법 3: Normalized Sum - 점수 정규화 후 합
# 장점: 점수 스케일 차이 보정
retriever = KoreanHybridRetriever(
    tokenizer=tokenizer,
    fusion_method=FusionMethod.NORMALIZED_SUM
)
```

### 3.3 실제 사용 시나리오

```
[시나리오: 복잡한 보험 질문]

질문: "보험료를 연체하면 계약이 어떻게 되나요?"

[BM25만 사용]
1. 형태소 분석: ["보험료", "연체", "계약", "되다"]
2. 검색 결과:
   - "보험료 납입 기간은 20년입니다" (토큰 겹침 많음)
   - "보험료 미납 시 계약이 해지됩니다" (토큰 겹침 적음)
3. 문제: 정확한 답변이 2위로 밀림

[Dense만 사용]
1. 의미 유사도 계산
2. 검색 결과:
   - "보험료 미납 시 계약이 해지됩니다" (의미 유사)
   - "보험료 연체 시 계약 해지 가능" (의미 유사)
3. 문제: "연체"와 "미납"의 미묘한 차이 구분 어려움

[하이브리드 검색]
1. BM25: "연체" 정확 매칭 강조
2. Dense: "미납", "연체" 의미 유사도 고려
3. RRF 융합:
   - "보험료 연체 시 계약이 해지됩니다" (1위) ✅
   - "보험료 미납 시 계약이 해지됩니다" (2위)
4. 결과: 정확한 답변 + 관련 정보 균형
```

---

## 4. Korean Retrieval Port Interfaces

### 4.1 해결하는 문제

#### 문제: 어댑터와 도메인 로직의 결합도

기존에는 구체적인 구현체에 직접 의존:

```python
# ❌ 나쁜 예: 구체적 구현에 의존
from evalvault.adapters.outbound.nlp.korean.bm25_retriever import KoreanBM25Retriever

class SomeService:
    def __init__(self):
        self.retriever = KoreanBM25Retriever(...)  # 구체적 구현에 의존
```

### 4.2 제공하는 효용

#### 효용 1: Hexagonal Architecture 준수

포트 인터페이스를 통한 의존성 역전:

```python
# ✅ 좋은 예: 포트 인터페이스에 의존
from evalvault.ports.outbound.korean_nlp_port import KoreanRetrieverPort

class SomeService:
    def __init__(self, retriever: KoreanRetrieverPort):  # 인터페이스에 의존
        self.retriever = retriever

# 구현체 교체 가능
bm25_retriever = KoreanBM25Retriever(tokenizer)
hybrid_retriever = KoreanHybridRetriever(tokenizer, embedding_func)
service = SomeService(retriever=hybrid_retriever)  # 쉽게 교체
```

#### 효용 2: 테스트 용이성

모킹을 통한 단위 테스트:

```python
# 테스트용 모킹 구현
class MockKoreanRetriever(KoreanRetrieverPort):
    def search(self, query: str, top_k: int) -> list[RetrievalResult]:
        return [RetrievalResult(document="mock", score=1.0)]

# 테스트
def test_service():
    mock_retriever = MockKoreanRetriever()
    service = SomeService(retriever=mock_retriever)
    # 실제 검색 없이 로직 테스트 가능
```

#### 효용 3: 확장성

새로운 검색 알고리즘 추가 용이:

```python
# 새로운 검색 알고리즘 추가
class KoreanColBERTRetriever(KoreanRetrieverPort):
    """ColBERT 기반 검색기"""
    def search(self, query: str, top_k: int) -> list[RetrievalResult]:
        # ColBERT 구현
        ...

# 기존 코드 수정 없이 사용 가능
service = SomeService(retriever=KoreanColBERTRetriever(...))
```

---

## 5. 통합 효용 (전체 시스템 관점)

### 5.1 EvalVault 평가 파이프라인 개선

```
[기존 평가 파이프라인]
Dataset → RagasEvaluator → EvaluationRun
    ↓
문제: 한국어 특성 미반영
    - 공백 기반 키워드 추출
    - 의미 단위 청킹 부재
    - 검색 품질 저하

[한국어 최적화 파이프라인]
Dataset → RagasEvaluator → EvaluationRun
    ↓
한국어 최적화 적용:
    ├─> KoreanDocumentChunker: 의미 단위 청킹
    ├─> KoreanBM25Retriever: 형태소 분석 기반 검색
    └─> KoreanHybridRetriever: 하이브리드 검색
    ↓
결과: 평가 품질 향상
    - 더 정확한 컨텍스트 제공
    - 더 나은 검색 결과
    - 더 높은 Faithfulness 점수
```

### 5.2 NLP Analysis 개선

```
[기존 NLP Analysis]
NLPAnalysisAdapter.extract_keywords()
    ↓
공백 기반 키워드 추출:
    키워드: ['보험료가', '얼마인가요', '무엇인가요', '가능합니다']

[한국어 최적화 NLP Analysis]
NLPAnalysisAdapter.extract_keywords()
    ↓
형태소 분석 기반 키워드 추출:
    키워드: ['보험료', '보장', '가입', '보험', '납입', '사망', '만기', '연금']
    ↓
효과:
    - 의미있는 키워드만 추출
    - 조사/어미 제거로 핵심 의미 강조
    - 키워드 정확도 60% → 85%+ 향상 예상
```

### 5.3 Knowledge Graph 생성 개선

```
[기존 KG 생성]
EntityExtractor.extract_entities()
    ↓
공백 기반 엔티티 추출:
    "삼성생명의 종신보험" → ["삼성생명의", "종신보험"] (부정확)

[한국어 최적화 KG 생성]
EntityExtractor.extract_entities()
    ↓
형태소 분석 기반 엔티티 추출:
    "삼성생명의 종신보험" → ["삼성생명", "종신보험"] (정확)
    ↓
효과:
    - 더 정확한 엔티티 추출
    - 더 나은 관계 추출
    - 더 정확한 KG → 더 나은 테스트셋 생성
```

---

## 6. 정량적 성과 예측

### 6.1 검색 성능 개선

| 메트릭 | Before (공백 기반) | After (형태소 분석) | 개선율 |
|--------|-------------------|-------------------|--------|
| **Recall@5** | 60-70% (추정) | 75-85% | **+15-25%** |
| **Precision@5** | 65-75% (추정) | 80-90% | **+10-15%** |
| **MRR** | 0.65-0.75 (추정) | 0.80-0.90 | **+15-20%** |

### 6.2 평가 품질 개선

| 메트릭 | Before | After | 개선율 |
|--------|--------|-------|--------|
| **Faithfulness** | Baseline | +5-10% | **+5-10%** |
| **Answer Relevancy** | Baseline | +3-8% | **+3-8%** |
| **Context Precision** | Baseline | +10-15% | **+10-15%** |

### 6.3 NLP Analysis 개선

| 항목 | Before | After | 개선율 |
|------|--------|-------|--------|
| **키워드 추출 정확도** | ~60% | 85%+ | **+25%** |
| **질문 유형 분류 정확도** | ~70% | 90%+ | **+20%** |

---

## 7. 실제 사용 사례

### 7.1 보험 상담 챗봇

```
[사용자 질문]
"보험료를 내지 않으면 어떻게 되나요?"

[기존 시스템]
1. 공백 기반 토큰화: ["보험료를", "내지", "않으면", "어떻게", "되나요"]
2. BM25 검색: 토큰 겹침 적음 → 낮은 점수
3. 검색 결과: "보험료 납입 기간은 20년입니다" (관련 있지만 직접 답변 아님)
4. 답변 품질: 낮음

[한국어 최적화 시스템]
1. 형태소 분석: ["보험료", "납입", "않다", "어떻게", "되다"]
2. 하이브리드 검색:
   - BM25: "보험료", "납입" 정확 매칭
   - Dense: "미납", "연체" 의미 유사도 고려
3. 검색 결과: "보험료 미납 시 계약이 해지됩니다" (정확한 답변)
4. 답변 품질: 높음 ✅
```

### 7.2 보험 약관 문서 검색

```
[문서: 10,000자 보험 약관]
[질문: "사망보험금은 얼마인가요?"]

[기존 시스템]
1. 문자 기반 청킹 (500자)
2. 문제: 문장 중간에 끊김
3. 검색: 공백 기반 → "사망보험금" 정확 매칭 어려움
4. 결과: 관련 문서 찾기 어려움

[한국어 최적화 시스템]
1. 문장 기반 청킹 (500 토큰)
2. 장점: 완전한 문장 단위
3. 검색: 형태소 분석 → "사망보험금" 정확 매칭
4. 결과: 정확한 답변 문서 찾기 성공 ✅
```

---

## 8. 핵심 가치 제안 요약

### 8.1 기술적 가치

1. **한국어 특성 반영**: 교착어 특성을 고려한 형태소 분석
2. **검색 품질 향상**: BM25 + Dense 하이브리드로 정확도와 의미 유사도 통합
3. **의미 무결성 보장**: 문장 기반 청킹으로 컨텍스트 손실 최소화

### 8.2 비즈니스 가치

1. **RAG 시스템 품질 향상**: 더 정확한 답변 제공
2. **사용자 만족도 향상**: 관련성 높은 검색 결과
3. **도메인 특화**: 보험 등 전문 도메인에서 정확한 용어 매칭

### 8.3 개발자 경험

1. **쉬운 통합**: 포트 인터페이스로 기존 코드 수정 최소화
2. **유연한 구성**: BM25/Dense 비중 조정 가능
3. **확장 가능**: 새로운 검색 알고리즘 추가 용이

---

## 9. 다음 단계 (미완성 작업)

### 9.1 Unit Tests 작성

**효용:**
- 기능 검증 및 회귀 방지
- 문서화 역할 (사용 예시)
- 리팩토링 안전성 보장

**필요한 테스트:**
- [ ] KoreanBM25Retriever 단위 테스트
- [ ] KoreanDocumentChunker 단위 테스트
- [ ] KoreanHybridRetriever 단위 테스트
- [ ] 포트 인터페이스 준수 테스트

### 9.2 기존 인프라 통합

**효용:**
- EvalVault 평가 파이프라인에 한국어 최적화 적용
- NLP Analysis에 형태소 분석 기반 키워드 추출 통합
- KG 생성에 형태소 분석 기반 엔티티 추출 통합

**통합 포인트:**
- [ ] NLPAnalysisAdapter에 KiwiTokenizer 통합
- [ ] EntityExtractor에 형태소 분석 적용
- [ ] DocumentChunker를 KoreanDocumentChunker로 교체 (한국어 감지 시)
- [ ] CLI에 `--korean` 옵션 추가

---

## 결론

개발 중인 한국어 RAG 최적화 기능들은:

1. **한국어의 교착어 특성**을 고려하여 검색 품질을 실질적으로 향상시킵니다
2. **의미 단위 청킹**으로 컨텍스트 무결성을 보장합니다
3. **하이브리드 검색**으로 정확한 용어 매칭과 의미 유사도를 통합합니다
4. **포트 인터페이스**로 확장 가능하고 테스트 가능한 아키텍처를 제공합니다

**예상 효과:**
- 검색 Recall@5: **+15-25% 향상**
- 검색 Precision@5: **+10-15% 향상**
- Faithfulness 점수: **+5-10% 향상**
- 키워드 추출 정확도: **60% → 85%+**

이러한 개선은 특히 **보험 도메인**과 같이 정확한 용어 매칭이 중요한 전문 도메인에서 큰 효과를 발휘할 것입니다.

---

**문서 끝**
